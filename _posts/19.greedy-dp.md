---
title: "[Algorithm] Greedy & Dynamic Programming"
excerpt: "Greedy & Dynamic Programming 는 정확히 말하자면 특정 알고리즘이라고 보기 보다는 문제 풀이 방식으로 이해하는 것이 좀 더 정확하다. Greedy & Dynamic Programming 를 이용해서 어떠한 방식으로 문제에 접근 하고 해결하는지 알아보자."
coverImage: "/assets/blog/19.greedy-dp/cover.jpg"
date: "2022-09-05T10:35:07.322Z"
author:
  name: Kihun Kim (deutschkihun)
  picture: "/assets/blog/authors/kihun.jpg"
ogImage:
  url: "/assets/blog/19.greedy-dp/cover.jpg"
---

Greedy & Dynamic Programming 는 정확히 말하자면 특정 알고리즘이라고 보기 보다는 문제 풀이 방식으로 이해하는 것이 좀 더 정확하다. Greedy & Dynamic Programming 를 이용해서 어떠한 방식으로 문제에 접근 하고 해결하는지 알아보자.

## 1.Greedy

그리디는 매 선택에서 지금 이 순간 가장 최적인 답을 선택하는 알고리즘이다. 하지만 그리드는 최적해를 보장하지는 않는다.

![greedy](/assets/blog/19.greedy-dp/greedy.png)

위의 예시에서 보듯이 A 지점에서는 최적은 짧은 거리인 10이지만 최종적으로 보면 65가 걸린다. 하지만 30을 택하면 지금은 차선이지만 최종 거리는 33이다.

## 2.Dynamic Programming

해결한 작은 문제로 큰 문제를 해결하는 문제 풀이 방식을 말한다. 다른 말로 **동적 계획법**이라고도 부른다. 동적 계획법의 기본 원리는 memoization (메모이제이션) 이다. 메모이제이션은 가장 작은 문제를 저장 했다가, 다른 문제를 해결할때 꺼내 쓰는 것이라고 이해하는 것이 좋다. 따라서 **이미 해결한 문제는 기록해두자 !== 메모이제이션**. 메모이제이션은 가장 작은 문제 단위로 나눌수 있는지 확인하고 최대한 나누어서 저장해 놓은 가장 작은 문제를 이용해서 해결하는 것이지, 매번 해결한 결과를 저장하는 것은 아니다. 메모이제이션을 표현하는 방식에는 **점화식**과 **밑에서 부터 계산** 하는 2가지 방식이 있다.

가장 대표적인 동적 계획법을 이용하여 계산하는 피보나치 수열으로 예를 들어보겠습니다.

점화식

```tsx
let memo = [];
function f(n) {
  if (n <= 1) return 1;
  if (memo[n]) return memo[n];
  return (memo[n] = f(n - 1) + f(n - 2));
}
```

밑에서 부터 계산

```tsx
function solution(n) {
  let arr = [1, 2];
  for (let i = 2; i < n; i++) {
    arr[i] = (arr[i - 1] + arr[i - 2]) % 1000000007;
  }
  return arr[n - 1];
}
```

## 2.1 Dynamic Programming 접근 방법

동적 계획법 문제 유형은 키워드만으로는 파악하기 어렵다. 그렇기 때문에

- 가장 작은 문제를 정의 할 수 있는지?
- 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는지?

확인하는 것이 중요하다. 또한 가장 기본적인 개념은 **재귀적으로 문제를 접근 + 중복제거** 라는 것을 잊지 말자.

#### reference: [fibonacci](https://onlydev.tistory.com/64)
