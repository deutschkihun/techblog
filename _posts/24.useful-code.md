---
title: "코딩 테스트에서 활용하기 좋은 유용한 로직 및 함수 모음"
excerpt: "Sorting."
coverImage: "/assets/blog/24.useful-code/cover.jpg"
date: "2022-09-05T17:35:07.322Z"
author:
  name: Kihun Kim (deutschkihun)
  picture: "/assets/blog/authors/kihun.jpg"
ogImage:
  url: "/assets/blog/24.useful-code/cover.jpg"
---

## 1. Combination (조합)

조합이란 서로 다른 n개원소 중 r개를 뽑아 만든 집합
겹치는거 고려 ex.) [ 1, 4, 5 ] 와 [1, 5, 4] 는 같은 것으로 취급해서 둘중 1개만 결과에 출력됨
O(Math.pow(2,n))

```tsx
function combinations(arr, r) {
  // 1개만 뽑는다면 그대로 조합을 반환한다. 탈출 조건으로도 사용된다.
  if (r === 1) return arr.map((v) => [v]);
  const result = [];

  // 요소를 순환한다
  arr.forEach((fixed, idx, arr) => {
    // 현재 index 이후 요소를 추출한다.
    // index번째는 선택된 요소
    const rest = arr.slice(idx + 1);
    // 선택된 요소 이전 요소들을 제외하고 재귀 호출한다.
    const temp = combinations(rest, r - 1);
    // 선택된 요소와 재귀 호출을 통해 구한 조합을 합쳐준다.
    const combine = temp.map((v) => [fixed, ...v]);
    // 결과 값을 추가한다.
    result.push(...combine);
  });
  // 결과 반화
  return result;
}

console.log(combinations([1, 2, 4, 5, 6, 4], 1));
```

## 2. Permutation (순열)

Permutation, Combination with recursion
순열이란 서로 다른 n개원소 중 r개를 택하여 일렬로 나열하는 경우를 말한다.
겹치는거 고려 하지 않음 ex.) [ 1, 4, 5 ] ,[ 1, 5, 4 ]]
O(n!)

```tsx
function permutations(arr, r) {
  if (r === 1) return arr.map((v) => [v]);
  let result = [];

  arr.forEach((fixed, idx, arr) => {
    // 현재 index를 제외한 요소를 추출한다.
    // index번째는 선택된 요소
    const rest = arr.filter((_, index) => index !== idx);
    // 선택된 요소를 제외하고 재귀 호출한다.
    const temp = permutations(rest, r - 1);
    // 선택된 요소와 재귀 호출을 통해 구한 순열을 합쳐준다.
    const combine = temp.map((v) => [fixed, ...v]);
    // 결과 값을 추가한다.
    result.push(...combine);
  });
  // 결과 반환
  return result;
}

console.log("permutation", permutations([1, 4, 5, 6, 3], 3));
```

## 3. fatorial

```tsx
function factorialize1(num) {
  if (num < 0) return -1;
  else if (num == 0) return 1;
  else {
    return num * factorialize1(num - 1);
  }
}

function factorialize2(num) {
  let result = num;
  if (num === 0 || num === 1) return 1;
  while (num > 1) {
    num--;
    result *= num;
  }
  return result;
}
```

## 4. Prime number (소수)

```tsx
// 1은 소수가 아니다.
// find prime number
// 1. O(n)
function findPN(num) {
  for (let i = 2; i < num; i++) {
    if (num % i === 0) return false;
  }
  return true;
}

// 2. 그 어떤 소수도 n의 제곱근보다 큰 수로 나눠질 수 없다. N의 제곱근은 제곱해서 N가 되는 모든 수
// O(sqrt(n))
function findPN2(num) {
  for (let i = 2; i * i <= num; i++) {
    if (num % i === 0) return false;
  }
  return true;
}

// 3. eratosthenes prime numbers algorithm: O(n * log(logn))
// https://stackoverflow.com/questions/16472012/what-would-cause-an-algorithm-to-have-olog-log-n-complexity
function findNumberOfPN(num) {
  const prime = [false, false, ...Array(num - 1).fill(true)];

  for (let i = 2; i * i <= num; i++) {
    if (prime[i]) {
      for (let j = i * 2; j <= num; j += i) {
        prime[j] = false;
      }
    }
  }

  // counting prime number
  return prime.reduce((acc, item) => {
    if (item) acc += 1;
    return acc;
  });
}

// returnAllPN
function returnAllPN(num) {
  const prime = [false, false, ...Array(num - 1).fill(true)];

  for (let i = 2; i * i <= num; i++) {
    if (prime[i]) {
      for (let j = i * 2; j <= num; j += i) {
        prime[j] = false;
      }
    }
  }

  return prime.reduce((acc, cv, ci) => {
    if (cv) acc.push(ci);
    return acc;
  }, []);
}
```

## 5. localeCompare (자바스크립트 내장함수)

```tsx
// 알파벳순서

console.log("a".localeCompare("c"));
// negative value -> "a" is before "c"

console.log("check".localeCompare("against"));
// positive value) -> "check" comes after "against"

console.log("a".localeCompare("a")); //
// zero -> "a" and "a" are equivalent

const arr = ["réservé", "cliché", "adieu"];
console.log(arr.sort((a, b) => a.localeCompare(b)));

// string ordering
const str = "Zbcdefg";
console.log([...str].sort().reverse().join(""));
console.log([...str].sort().join(""));
```

## 6. Array-flatten

1.foreach

```tsx
// flat aray

let arr = [1, 2, [[3, 4]], [5, 6, 7, 8, 9], [10, 11, 12]];

function flatten(arr) {
  let result = [];
  arr.forEach((k) => {
    if (Array.isArray(k)) {
      result = result.concat(flatten(k));
    } else {
      result.push(k);
    }
  });
  return result;
}

console.log(flatten(arr));
```

2.reduce

```tsx
let arr = [1, 2, [[3, 4]], [5, 6, 7, 8, 9], [10, 11, 12]];

function flatten(arr) {
  return arr.reduce((a, b) => {
    if (Array.isArray(b)) {
      a = a.concat(flatten(b));
    } else {
      a.push(b);
    }
    return a;
  }, []);
}

console.log(flatten(arr));
```

## 7. find duplicated elements

1.filter

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

let find = arr.filter((k, i, arr) => {
  return arr.indexOf(k) !== i;
});
console.log(find);
```

2.hash-map

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

let hash = new Map();
for (const k of arr) {
  hash.set(k, hash.get(k) + 1 || 1);
}

const nn = [...hash].filter(([_, count]) => count > 1).map((e) => e[0]);

console.log(nn);
```

3.reduce

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

const find = arr.reduce(
  (acc, cv) => {
    if (!acc.unique.includes(cv)) acc.unique.push(cv);
    else acc.find.push(cv);
    return acc;
  },
  {
    unique: [],
    find: [],
  }
);

cosnole.log(find);
```

## 8. remove duplicated elements

1.reduce

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

const unique = arr.reduce((a, b) => {
  if (!a.includes(b)) a.push(b);
  return a;
}, []);

console.log(unique);
```

2.for-loop

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

let pure = [];
for (let i = 0; i < arr.length; i++) {
  if (!pure.includes(arr[i])) pure.push(arr[i]);
}
console.log(pure);
```

3.filter

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

let unique = arr.filter((e, i, arr) => {
  return arr.indexOf(e) === i;
});
```

4.set

```tsx
let arr = ["js", 1, 2, "js", 1, "startup", "2", true, "startup", false, true];

console.log([...new Set(arr)]);
```

## 9. reverse array

1.while

```tsx
let temp = [9, 2, 8, 5, 5, 6, 2, 3];

function reverse(array) {
  let result = [];
  while (array.length) {
    result.push(array.pop());
  }

  return result;
}

console.log(reverse(temp));
```

2.for-loop

```tsx
let temp = [9, 2, 8, 5, 5, 6, 2, 3];

let len = temp.length - 1;
for (let i = 0; i <= len / 2; i++) {
  let cnt = temp[i];
  temp[i] = temp[len - i];
  temp[len - i] = cnt;
}
console.log(temp);
```

3.reduce-right

```tsx
let temp = [9, 2, 8, 5, 5, 6, 2, 3];

temp.reduceRight((prev, curr) => {
  prev.push(curr);
  return prev;
}, []);
```

4.for-loop reverse

```tsx
let temp = [9, 2, 8, 5, 5, 6, 2, 3];

let reverse = [];
for (let i = temp.length; i > 0; i--) {
  reverse.push(temp[i - 1]);
}
console.log(reverse);
```

## 10. Squre overlapping

겹치지 않는 사각형. 주어진 좌표값들을 이용해서 박스를 그린다. 입력받은 순서대로 그린다. 만약 이미 그려진 것들과 새로 그리게 될 박스가 겹친다면 그리지 않고 다음거로 넘어간다.좌표값은 [x1,y1,x2,y2] 로 들어간다.

```tsx
function isBoxOverlap(rec1, rec2) {
  let overlap = false;
  const [E, F, G, H] = rec2;
  for (const temp of rec1) {
    const [A, B, C, D] = temp;
    if (E >= C || G <= A || F >= D || H <= B) {
      continue;
    } else {
      overlap = true;
      break;
    }
  }
  return overlap;
}

function solution(boxes) {
  let drawnBox = [boxes[0]];
  let answer = [0];
  boxes.forEach((box, idx) => {
    // 첫번째 pass
    if (!idx) return;
    if (isBoxOverlap(drawnBox, box)) return;
    else {
      drawnBox.push(box);
      answer.push(idx);
    }
  });
  return answer;
}

const boxlist = [
  [1, 1, 3, 3],
  [2, 2, 4, 4],
  [1, 5, 6, 7],
  [3, 3, 5, 5],
];
console.log(solution(boxlist)); // [0,2,3], 두번째꺼는 겹쳐서 넘어간다.
```

## 11.String Number sorting

```tsx
const strNum = [
  "a10",
  "a2",
  "a1",
  "a12",
  "j5",
  "j10",
  "j2",
  "j1",
  "j13",
  "j19",
];

// 1.오름차순
const sorting = (arr) => {
  return arr.sort((a, b) => {
    return a.localeCompare(b, undefined, {
      numeric: true,
      sensitivity: "base",
    });
  });
};

console.log(sorting(strNum));
```

## 12. Find matched string

```tsx
function stringCompare(str1, str2) {
  if (str1.length !== str2.length) return false;
  for (let i = 0; i < str1.length; i++) {
    if (str1[i] !== "?" && str1[i] !== str2[i]) return false;
  }
  return true;
}

function solution(words, queries) {
  let list = new Map();
  for (const query of queries) {
    list.set(query, 0);
    for (const word of words) {
      if (stringCompare(query, word)) {
        list.set(query, list.get(query) + 1 || 1);
      }
    }
  }
  return [...list].map((e) => e[1]);
}

const words = [
  "test",
  "tikitaka",
  "techtaka",
  "tech",
  "tell",
  "techargo",
  "argoport",
];
const queries = ["te??", "??c?taka", "t???taka", "pro?"];
console.log(solution(words, queries));
```
